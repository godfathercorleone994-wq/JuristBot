import logging
import csv
import io
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CallbackQueryHandler
from app.core.registry import module_registry
from app.core.database import mongo_db
from app.core.config import Config

logger = logging.getLogger(__name__)

class AdminPanel:
    def __init__(self):
        self.admin_id = Config.ADMIN_TELEGRAM_ID
    
    def is_admin(self, user_id: int) -> bool:
        """Verificar se o usu√°rio √© admin"""
        return user_id == self.admin_id
    
    async def admin_access_required(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Middleware para verificar acesso admin"""
        user_id = update.effective_user.id
        if not self.is_admin(user_id):
            await update.message.reply_text("‚ùå Acesso restrito. Apenas administradores podem usar este comando.")
            return False
        return True
    
    async def admin_dashboard(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Painel principal do administrador"""
        if not await self.admin_access_required(update, context):
            return
        
        # Buscar estat√≠sticas gerais
        stats = await self.get_system_stats()
        
        dashboard_text = (
            "üëë **Painel Administrativo - JuristBot**\n\n"
            f"üìä **Estat√≠sticas do Sistema:**\n"
            f"‚Ä¢ üë• Usu√°rios totais: {stats['total_users']}\n"
            f"‚Ä¢ üìà Usu√°rios ativos (30d): {stats['active_users_30d']}\n"
            f"‚Ä¢ ü§ñ Afiliados: {stats['total_affiliates']}\n"
            f"‚Ä¢ üîç Consultas totais: {stats['total_queries']}\n"
            f"‚Ä¢ üí∞ Comiss√µes totais: R$ {stats['total_commissions']:.2f}\n\n"
            
            f"üìà **Hoje:**\n"
            f"‚Ä¢ ‚ûï Novos usu√°rios: {stats['new_users_today']}\n"
            f"‚Ä¢ üîç Consultas: {stats['queries_today']}\n"
            f"‚Ä¢ üí∏ Comiss√µes: R$ {stats['commissions_today']:.2f}\n\n"
            
            f"‚öôÔ∏è **Status do Sistema:**\n"
            f"‚Ä¢ üóÑÔ∏è MongoDB: {'‚úÖ' if mongo_db.is_connected else '‚ùå'}\n"
            f"‚Ä¢ ü§ñ APIs IA: {stats['available_ia_apis']}\n"
            f"‚Ä¢ üïí Uptime: {stats['system_uptime']}\n"
        )
        
        keyboard = [
            [InlineKeyboardButton("üìä Estat√≠sticas Detalhadas", callback_data="admin_stats")],
            [InlineKeyboardButton("üë• Gerenciar Usu√°rios", callback_data="admin_users")],
            [InlineKeyboardButton("ü§ñ Gerenciar Afiliados", callback_data="admin_affiliates")],
            [InlineKeyboardButton("üîç Consultas Recentes", callback_data="admin_queries")],
            [InlineKeyboardButton("üí∞ Relat√≥rio Financeiro", callback_data="admin_finance")],
            [InlineKeyboardButton("‚öôÔ∏è Configura√ß√µes", callback_data="admin_settings")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(dashboard_text, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def get_system_stats(self) -> Dict:
        """Obter estat√≠sticas do sistema"""
        try:
            # Usu√°rios
            users = mongo_db.get_collection('users')
            total_users = users.count_documents({}) if users else 0
            
            # Usu√°rios ativos (√∫ltimos 30 dias)
            thirty_days_ago = datetime.utcnow() - timedelta(days=30)
            active_users_30d = users.count_documents({
                'last_activity': {'$gte': thirty_days_ago}
            }) if users else 0
            
            # Afiliados
            affiliates = mongo_db.get_collection('affiliates')
            total_affiliates = affiliates.count_documents({}) if affiliates else 0
            
            # Consultas
            queries = mongo_db.get_collection('queries')
            total_queries = queries.count_documents({}) if queries else 0
            
            # Consultas de hoje
            today_start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
            queries_today = queries.count_documents({
                'created_at': {'$gte': today_start}
            }) if queries else 0
            
            # Comiss√µes
            total_commissions = 0
            commissions_today = 0
            if affiliates:
                affiliate_stats = affiliates.aggregate([
                    {
                        '$group': {
                            '_id': None,
                            'total_commission': {'$sum': '$total_commission'},
                            'today_commission': {
                                '$sum': {
                                    '$cond': [
                                        {'$gte': ['$last_commission_date', today_start]},
                                        '$pending_commission',
                                        0
                                    ]
                                }
                            }
                        }
                    }
                ])
                result = list(affiliate_stats)
                if result:
                    total_commissions = result[0].get('total_commission', 0)
                    commissions_today = result[0].get('today_commission', 0)
            
            # Novos usu√°rios hoje
            new_users_today = users.count_documents({
                'created_at': {'$gte': today_start}
            }) if users else 0
            
            # APIs de IA dispon√≠veis
            from app.core.config import Config
            available_apis = Config.get_available_ia_apis()
            
            # Uptime do sistema (simulado)
            system_uptime = "24h 15m"
            
            return {
                'total_users': total_users,
                'active_users_30d': active_users_30d,
                'total_affiliates': total_affiliates,
                'total_queries': total_queries,
                'queries_today': queries_today,
                'total_commissions': total_commissions,
                'commissions_today': commissions_today,
                'new_users_today': new_users_today,
                'available_ia_apis': len(available_apis),
                'system_uptime': system_uptime
            }
            
        except Exception as e:
            logger.error(f"Erro ao buscar estat√≠sticas: {e}")
            return {}
    
    async def admin_stats_detailed(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Estat√≠sticas detalhadas do sistema"""
        query = update.callback_query
        await query.answer()
        
        if not self.is_admin(query.from_user.id):
            await query.edit_message_text("‚ùå Acesso negado.")
            return
        
        # Estat√≠sticas por tipo de consulta
        queries = mongo_db.get_collection('queries')
        if queries:
            pipeline = [
                {
                    '$group': {
                        '_id': '$query_type',
                        'count': {'$sum': 1},
                        'last_24h': {
                            '$sum': {
                                '$cond': [
                                    {'$gte': ['$created_at', datetime.utcnow() - timedelta(hours=24)]},
                                    1,
                                    0
                                ]
                            }
                        }
                    }
                },
                {'$sort': {'count': -1}}
            ]
            query_stats = list(queries.aggregate(pipeline))
        else:
            query_stats = []
        
        stats_text = "üìà **Estat√≠sticas Detalhadas**\n\n"
        
        if query_stats:
            stats_text += "üîç **Consultas por Tipo:**\n"
            for stat in query_stats[:10]:  # Top 10 tipos
                stats_text += f"‚Ä¢ {stat['_id']}: {stat['count']} total, {stat['last_24h']} √∫ltimas 24h\n"
            stats_text += "\n"
        
        # Usu√°rios por per√≠odo
        users = mongo_db.get_collection('users')
        if users:
            user_stats = {
                'last_24h': users.count_documents({
                    'created_at': {'$gte': datetime.utcnow() - timedelta(hours=24)}
                }),
                'last_7d': users.count_documents({
                    'created_at': {'$gte': datetime.utcnow() - timedelta(days=7)}
                }),
                'last_30d': users.count_documents({
                    'created_at': {'$gte': datetime.utcnow() - timedelta(days=30)}
                })
            }
            
            stats_text += (
                f"üë• **Crescimento de Usu√°rios:**\n"
                f"‚Ä¢ √öltimas 24h: {user_stats['last_24h']}\n"
                f"‚Ä¢ √öltimos 7 dias: {user_stats['last_7d']}\n"
                f"‚Ä¢ √öltimos 30 dias: {user_stats['last_30d']}\n"
            )
        
        keyboard = [[InlineKeyboardButton("üîô Voltar", callback_data="admin_back")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(stats_text, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def admin_manage_users(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Gerenciamento de usu√°rios"""
        query = update.callback_query
        await query.answer()
        
        if not self.is_admin(query.from_user.id):
            await query.edit_message_text("‚ùå Acesso negado.")
            return
        
        users = mongo_db.get_collection('users')
        if not users:
            await query.edit_message_text("‚ùå Erro ao acessar banco de dados.")
            return
        
        # Usu√°rios mais ativos
        pipeline = [
            {
                '$lookup': {
                    'from': 'queries',
                    'localField': 'user_id',
                    'foreignField': 'user_id',
                    'as': 'user_queries'
                }
            },
            {
                '$addFields': {
                    'query_count': {'$size': '$user_queries'},
                    'last_active': {'$max': '$user_queries.created_at'}
                }
            },
            {'$sort': {'query_count': -1}},
            {'$limit': 10}
        ]
        
        top_users = list(users.aggregate(pipeline))
        
        users_text = "üë• **Top 10 Usu√°rios Mais Ativos**\n\n"
        
        for i, user in enumerate(top_users, 1):
            username = user.get('username', 'Sem username')
            first_name = user.get('first_name', 'N/A')
            query_count = user.get('query_count', 0)
            
            users_text += f"{i}. {first_name} (@{username}): {query_count} consultas\n"
        
        users_text += "\nüí° *Use /exportusers para exportar lista completa*"
        
        keyboard = [
            [InlineKeyboardButton("üì§ Exportar Usu√°rios", callback_data="admin_export_users")],
            [InlineKeyboardButton("üîÑ Atualizar", callback_data="admin_users")],
            [InlineKeyboardButton("üîô Voltar", callback_data="admin_back")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(users_text, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def admin_export_users(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Exportar lista de usu√°rios para CSV"""
        query = update.callback_query
        await query.answer()
        
        if not self.is_admin(query.from_user.id):
            await query.edit_message_text("‚ùå Acesso negado.")
            return
        
        users = mongo_db.get_collection('users')
        if not users:
            await query.edit_message_text("‚ùå Erro ao acessar banco de dados.")
            return
        
        # Buscar todos os usu√°rios
        all_users = list(users.find({}, {
            'user_id': 1, 
            'username': 1, 
            'first_name': 1, 
            'last_name': 1, 
            'created_at': 1,
            'last_activity': 1,
            'is_affiliate': 1
        }).sort('created_at', -1))
        
        # Criar CSV em mem√≥ria
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Escrever cabe√ßalho
        writer.writerow([
            'ID', 'Username', 'Primeiro Nome', '√öltimo Nome', 
            'Data de Cria√ß√£o', '√öltima Atividade', '√â Afiliado'
        ])
        
        # Escrever dados
        for user in all_users:
            writer.writerow([
                user.get('user_id', ''),
                user.get('username', ''),
                user.get('first_name', ''),
                user.get('last_name', ''),
                user.get('created_at', '').strftime('%Y-%m-%d %H:%M:%S') if user.get('created_at') else '',
                user.get('last_activity', '').strftime('%Y-%m-%d %H:%M:%S') if user.get('last_activity') else '',
                'Sim' if user.get('is_affiliate') else 'N√£o'
            ])
        
        # Preparar arquivo para envio
        csv_data = output.getvalue().encode('utf-8')
        csv_file = io.BytesIO(csv_data)
        csv_file.name = f'usuarios_juristbot_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
        
        await context.bot.send_document(
            chat_id=query.from_user.id,
            document=csv_file,
            filename=csv_file.name,
            caption=f"üìä Exporta√ß√£o de Usu√°rios - {len(all_users)} usu√°rios"
        )
        
        # Atualizar mensagem original
        await query.edit_message_text(
            f"‚úÖ Arquivo CSV exportado com sucesso!\n\n"
            f"üìÅ {len(all_users)} usu√°rios exportados.",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üîô Voltar", callback_data="admin_users")
            ]])
        )
    
    async def admin_manage_affiliates(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Gerenciamento de afiliados"""
        query = update.callback_query
        await query.answer()
        
        if not self.is_admin(query.from_user.id):
            await query.edit_message_text("‚ùå Acesso negado.")
            return
        
        affiliates = mongo_db.get_collection('affiliates')
        if not affiliates:
            await query.edit_message_text("‚ùå Nenhum afiliado encontrado.")
            return
        
        # Top afiliados por comiss√£o
        top_affiliates = list(affiliates.find().sort('total_commission', -1).limit(10))
        
        affiliates_text = "ü§ñ **Top 10 Afiliados por Comiss√£o**\n\n"
        
        for i, affiliate in enumerate(top_affiliates, 1):
            username = affiliate.get('username', 'Sem username')
            first_name = affiliate.get('first_name', 'N/A')
            total_commission = affiliate.get('total_commission', 0)
            referral_count = affiliate.get('referral_count', 0)
            
            affiliates_text += (
                f"{i}. {first_name} (@{username})\n"
                f"   üí∞ R$ {total_commission:.2f} | üë• {referral_count} indica√ß√µes\n"
            )
        
        keyboard = [
            [InlineKeyboardButton("üì§ Exportar Afiliados", callback_data="admin_export_affiliates")],
            [InlineKeyboardButton("üîÑ Atualizar", callback_data="admin_affiliates")],
            [InlineKeyboardButton("üîô Voltar", callback_data="admin_back")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(affiliates_text, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def admin_recent_queries(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Consultas recentes do sistema"""
        query = update.callback_query
        await query.answer()
        
        if not self.is_admin(query.from_user.id):
            await query.edit_message_text("‚ùå Acesso negado.")
            return
        
        queries = mongo_db.get_collection('queries')
        if not queries:
            await query.edit_message_text("‚ùå Nenhuma consulta encontrada.")
            return
        
        # √öltimas 10 consultas
        recent_queries = list(queries.find().sort('created_at', -1).limit(10))
        
        queries_text = "üîç **√öltimas 10 Consultas**\n\n"
        
        for i, q in enumerate(recent_queries, 1):
            user_id = q.get('user_id', 'N/A')
            query_type = q.get('query_type', 'N/A')
            query_data = q.get('query_data', '')[:50] + "..." if len(q.get('query_data', '')) > 50 else q.get('query_data', '')
            created_at = q.get('created_at', '').strftime('%H:%M') if q.get('created_at') else 'N/A'
            
            queries_text += f"{i}. üïí {created_at} | üë§ {user_id}\n"
            queries_text += f"   üìù {query_type}: {query_data}\n\n"
        
        keyboard = [
            [InlineKeyboardButton("üì§ Exportar Consultas", callback_data="admin_export_queries")],
            [InlineKeyboardButton("üîÑ Atualizar", callback_data="admin_queries")],
            [InlineKeyboardButton("üîô Voltar", callback_data="admin_back")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(queries_text, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def admin_financial_report(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Relat√≥rio financeiro"""
        query = update.callback_query
        await query.answer()
        
        if not self.is_admin(query.from_user.id):
            await query.edit_message_text("‚ùå Acesso negado.")
            return
        
        affiliates = mongo_db.get_collection('affiliates')
        if not affiliates:
            await query.edit_message_text("‚ùå Dados financeiros n√£o dispon√≠veis.")
            return
        
        # Estat√≠sticas financeiras
        pipeline = [
            {
                '$group': {
                    '_id': None,
                    'total_commission': {'$sum': '$total_commission'},
                    'pending_commission': {'$sum': '$pending_commission'},
                    'paid_commission': {'$sum': '$paid_commission'},
                    'active_affiliates': {'$sum': 1}
                }
            }
        ]
        
        result = list(affiliates.aggregate(pipeline))
        if not result:
            finance_data = {'total_commission': 0, 'pending_commission': 0, 'paid_commission': 0, 'active_affiliates': 0}
        else:
            finance_data = result[0]
        
        finance_text = (
            "üí∞ **Relat√≥rio Financeiro**\n\n"
            f"‚Ä¢ üíµ Comiss√µes Totais: R$ {finance_data.get('total_commission', 0):.2f}\n"
            f"‚Ä¢ ‚è≥ Comiss√µes Pendentes: R$ {finance_data.get('pending_commission', 0):.2f}\n"
            f"‚Ä¢ ‚úÖ Comiss√µes Pagas: R$ {finance_data.get('paid_commission', 0):.2f}\n"
            f"‚Ä¢ ü§ñ Afiliados Ativos: {finance_data.get('active_affiliates', 0)}\n\n"
            
            "üí° *Valores baseados no sistema de comiss√µes de 10-20%*"
        )
        
        keyboard = [
            [InlineKeyboardButton("üìä Estat√≠sticas Detalhadas", callback_data="admin_stats")],
            [InlineKeyboardButton("üîô Voltar", callback_data="admin_back")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(finance_text, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def admin_settings(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Configura√ß√µes do sistema"""
        query = update.callback_query
        await query.answer()
        
        if not self.is_admin(query.from_user.id):
            await query.edit_message_text("‚ùå Acesso negado.")
            return
        
        from app.core.config import Config
        
        settings_text = (
            "‚öôÔ∏è **Configura√ß√µes do Sistema**\n\n"
            f"‚Ä¢ ü§ñ Nome do Bot: {Config.BOT_NAME}\n"
            f"‚Ä¢ üë§ Admin ID: {Config.ADMIN_TELEGRAM_ID}\n"
            f"‚Ä¢ üóÑÔ∏è MongoDB: {'‚úÖ Conectado' if mongo_db.is_connected else '‚ùå Desconectado'}\n\n"
            
            "üîß **APIs Configuradas:**\n"
        )
        
        # Status das APIs de IA
        from app.modules.ia_services import ai_service
        apis_status = [
            f"‚Ä¢ DeepSeek: {'‚úÖ' if ai_service.deepseek_available else '‚ùå'}",
            f"‚Ä¢ Gemini: {'‚úÖ' if ai_service.gemini_available else '‚ùå'}",
            f"‚Ä¢ OpenAI: {'‚úÖ' if ai_service.openai_available else '‚ùå'}"
        ]
        
        settings_text += "\n".join(apis_status)
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Verificar Conex√µes", callback_data="admin_check_connections")],
            [InlineKeyboardButton("üîô Voltar", callback_data="admin_back")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(settings_text, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def admin_check_connections(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Verificar status das conex√µes"""
        query = update.callback_query
        await query.answer()
        
        if not self.is_admin(query.from_user.id):
            await query.edit_message_text("‚ùå Acesso negado.")
            return
        
        # Testar conex√£o com MongoDB
        mongo_status = "‚úÖ Conectado" if mongo_db.is_connected else "‚ùå Desconectado"
        
        # Testar APIs de IA
        from app.modules.ia_services import ai_service
        
        connection_text = (
            "üîå **Verifica√ß√£o de Conex√µes**\n\n"
            f"‚Ä¢ üóÑÔ∏è MongoDB: {mongo_status}\n"
            "‚Ä¢ ü§ñ APIs de IA:\n"
        )
        
        # Testar cada API
        test_results = []
        
        # DeepSeek
        try:
            deepseek_test = await ai_service.ask_deepseek("Teste de conex√£o")
            deepseek_status = "‚úÖ OK" if deepseek_test else "‚ùå Falha"
        except:
            deepseek_status = "‚ùå Erro"
        test_results.append(f"  - DeepSeek: {deepseek_status}")
        
        # Gemini
        try:
            gemini_test = await ai_service.ask_gemini("Teste de conex√£o")
            gemini_status = "‚úÖ OK" if gemini_test else "‚ùå Falha"
        except:
            gemini_status = "‚ùå Erro"
        test_results.append(f"  - Gemini: {gemini_status}")
        
        # OpenAI
        try:
            openai_test = await ai_service.ask_openai("Teste de conex√£o")
            openai_status = "‚úÖ OK" if openai_test else "‚ùå Falha"
        except:
            openai_status = "‚ùå Erro"
        test_results.append(f"  - OpenAI: {openai_status}")
        
        connection_text += "\n".join(test_results)
        
        keyboard = [[InlineKeyboardButton("üîô Voltar", callback_data="admin_settings")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(connection_text, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def admin_callback_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manipular callbacks do painel administrativo"""
        query = update.callback_query
        await query.answer()
        
        callback_data = query.data
        
        if callback_data == "admin_stats":
            await self.admin_stats_detailed(update, context)
        elif callback_data == "admin_users":
            await self.admin_manage_users(update, context)
        elif callback_data == "admin_affiliates":
            await self.admin_manage_affiliates(update, context)
        elif callback_data == "admin_queries":
            await self.admin_recent_queries(update, context)
        elif callback_data == "admin_finance":
            await self.admin_financial_report(update, context)
        elif callback_data == "admin_settings":
            await self.admin_settings(update, context)
        elif callback_data == "admin_export_users":
            await self.admin_export_users(update, context)
        elif callback_data == "admin_check_connections":
            await self.admin_check_connections(update, context)
        elif callback_data == "admin_back":
            await self.admin_dashboard_callback(update, context)
    
    async def admin_dashboard_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Voltar ao dashboard principal (vers√£o callback)"""
        query = update.callback_query
        await query.answer()
        
        if not self.is_admin(query.from_user.id):
            await query.edit_message_text("‚ùå Acesso negado.")
            return
        
        # Reutilizar a l√≥gica do dashboard principal
        stats = await self.get_system_stats()
        
        dashboard_text = (
            "üëë **Painel Administrativo - JuristBot**\n\n"
            f"üìä **Estat√≠sticas do Sistema:**\n"
            f"‚Ä¢ üë• Usu√°rios totais: {stats['total_users']}\n"
            f"‚Ä¢ üìà Usu√°rios ativos (30d): {stats['active_users_30d']}\n"
            f"‚Ä¢ ü§ñ Afiliados: {stats['total_affiliates']}\n"
            f"‚Ä¢ üîç Consultas totais: {stats['total_queries']}\n"
            f"‚Ä¢ üí∞ Comiss√µes totais: R$ {stats['total_commissions']:.2f}\n\n"
            
            f"üìà **Hoje:**\n"
            f"‚Ä¢ ‚ûï Novos usu√°rios: {stats['new_users_today']}\n"
            f"‚Ä¢ üîç Consultas: {stats['queries_today']}\n"
            f"‚Ä¢ üí∏ Comiss√µes: R$ {stats['commissions_today']:.2f}\n"
        )
        
        keyboard = [
            [InlineKeyboardButton("üìä Estat√≠sticas Detalhadas", callback_data="admin_stats")],
            [InlineKeyboardButton("üë• Gerenciar Usu√°rios", callback_data="admin_users")],
            [InlineKeyboardButton("ü§ñ Gerenciar Afiliados", callback_data="admin_affiliates")],
            [InlineKeyboardButton("üîç Consultas Recentes", callback_data="admin_queries")],
            [InlineKeyboardButton("üí∞ Relat√≥rio Financeiro", callback_data="admin_finance")],
            [InlineKeyboardButton("‚öôÔ∏è Configura√ß√µes", callback_data="admin_settings")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(dashboard_text, reply_markup=reply_markup, parse_mode='Markdown')
    
    async def broadcast_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Enviar mensagem broadcast para todos os usu√°rios"""
        if not await self.admin_access_required(update, context):
            return
        
        if not context.args:
            await update.message.reply_text(
                "üì¢ **Envio de Broadcast**\n\n"
                "üí° **Uso:** /broadcast <mensagem>\n\n"
                "Exemplo:\n"
                "`/broadcast Nova atualiza√ß√£o dispon√≠vel! Confira as novidades.`\n\n"
                "‚ö†Ô∏è *Esta mensagem ser√° enviada para todos os usu√°rios.*",
                parse_mode='Markdown'
            )
            return
        
        message = " ".join(context.args)
        users = mongo_db.get_collection('users')
        
        if not users:
            await update.message.reply_text("‚ùå Erro ao acessar banco de dados.")
            return
        
        # Buscar todos os usu√°rios
        all_users = users.find({}, {'user_id': 1})
        user_count = 0
        error_count = 0
        
        await update.message.reply_text(f"üì§ Iniciando broadcast para {users.count_documents({})} usu√°rios...")
        
        # Enviar mensagem para cada usu√°rio
        for user in all_users:
            try:
                user_id = user['user_id']
                await context.bot.send_message(
                    chat_id=user_id,
                    text=f"üì¢ **Mensagem do JuristBot:**\n\n{message}"
                )
                user_count += 1
                
                # Pequena pausa para evitar rate limiting
                import asyncio
                await asyncio.sleep(0.1)
                
            except Exception as e:
                error_count += 1
                logger.error(f"Erro ao enviar broadcast para {user_id}: {e}")
        
        await update.message.reply_text(
            f"‚úÖ Broadcast conclu√≠do!\n\n"
            f"‚Ä¢ ‚úÖ Enviadas: {user_count}\n"
            f"‚Ä¢ ‚ùå Erros: {error_count}\n"
            f"‚Ä¢ üìä Total: {user_count + error_count}"
        )

# Inst√¢ncia global do painel administrativo
admin_panel = AdminPanel()

# Registrar comandos administrativos
module_registry.register_command("admin", admin_panel.admin_dashboard, "Painel administrativo (apenas admin)")
module_registry.register_command("broadcast", admin_panel.broadcast_message, "Enviar mensagem para todos os usu√°rios (apenas admin)")

# Registrar handlers de callback
module_registry.register_callback("admin_.*", admin_panel.admin_callback_handler)

module_registry.register_module("admin")
